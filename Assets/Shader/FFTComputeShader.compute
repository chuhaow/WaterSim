// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CS_UpdateSpectrum
#pragma kernel CS_DFT
#pragma kernel GenerateNormalMap
#pragma kernel CS_FFT
#pragma kernel Assemble;
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
#define PI 3.14159265358979323846
#define SIZE 512
#define LOG_SIZE 9

float2 ComplexMult(float2 a, float2 b) {
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

float2 EulerFormula(float x) {
    return float2(cos(x), sin(x));
}

float2 ComplexExp(float2 a) {
    return float2(cos(a.y), sin(a.y) * exp(a.x));
}

//Robert Jenkins' 32 bit integer hash function (Todo: Correct this)
float JenkenHash(uint n){

   n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}


float2 BoxMullerTransform(float u1, float u2) {
    float sqr = sqrt(-2.0f * log(u1));
    return float2(sqr * cos(2 * PI * u2), sqr * sin(2 * PI * u2) );
}

//https://github.com/Scrawk/Phillips-Ocean/blob/master/Assets/PhillipsOcean/Scripts/Ocean.cs
float PhillipsSpectrum(float2 k){
    float kLen = length(k);
    if(kLen < 0.0001f) return 0.0f;


    float k_len2 = kLen * kLen;
    float k_len4 = k_len2 * k_len2;


    float2 wind = (float2(-50.5f, 1.0f));

    float kdotWind   = dot(normalize(k), normalize(wind));
	float k_dot_w2  = kdotWind * kdotWind * kdotWind * kdotWind * kdotWind * kdotWind;
   
    float windLen = length(wind);

    float Amp = 0.00000015f;
    float L = (windLen * windLen) / 9.8f;
    float L2 = L * L;

    float damping = 0.001f;
    float l2 = L2 * damping * damping;
    

    return Amp * (exp(-1.0f/( k_len2 * (L2))  ) ) / k_len4 * k_dot_w2 * exp(-k_len2 * l2)  ;

}

float2 SamplePhillipsSpec(float2 k, float2 rand )
{
    return 1.0f/sqrt(2.0f) * (rand) * sqrt(PhillipsSpectrum(k));
}

RWTexture2D<float4> _FourierTarget;
RWTexture2D<float4> _HeightTex, _NormalTex, _InitSpectrumTex, _DisplacementTex;
RWTexture2D<float2> _ProgSpectrumTex;
float _FrameTime;
int _FftSize, _LengthScale, _FftLogSize;
groupshared float4 groupBuffer[2][SIZE];
bool _Inverse, _Direction;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 dir = float2(-1, 1);
    dir = normalize(dir);

    uint seed = id.x + _FftSize + id.y + _FftSize;

    
    float halfN = _FftSize / 2.0f;

    float n = id.x - _FftSize / 2.0f;
    float m = id.y - _FftSize / 2.0f;

    float2 K = float2(n, m) * 2.0f * PI / _LengthScale;

    float2 gauss1 = BoxMullerTransform( JenkenHash(seed), JenkenHash(seed * seed));
    float2 gauss2 = BoxMullerTransform( JenkenHash(seed * seed * 0.25), JenkenHash(seed * seed * 2));

    float2 h0 = SamplePhillipsSpec(K, float2(gauss1.x, gauss2.y));
    float2 h0conj = SamplePhillipsSpec(-K, float2(gauss1.y, gauss2.x));
    
    _InitSpectrumTex[id.xy] = float4(h0, h0conj);
}

[numthreads(8,8,1)]
void CS_UpdateSpectrum(uint3 id : SV_DISPATCHTHREADID) {
    float4 initialSignal = _InitSpectrumTex[id.xy];
    //float2 h0 = initialSignal.xy;
    //float2 h0conj = initialSignal.zw;

    //float n = id.x - _FftSize / 2.0f;
    //float m = id.y - _FftSize/ 2.0f;

    //float2 K = float2(n, m) * 2.0f * PI / _LengthScale;
    //float w_0 = 2.0f * PI / 200.0f;
    //float dispersion = floor(sqrt(9.8f * length(K)) / w_0) * w_0 * _FrameTime;

    //_ProgSpectrumTex[id.xy] = ComplexMult(h0, EulerFormula(dispersion)) + ComplexMult(h0conj, EulerFormula(-dispersion));
    uint seed = id.x + _FftSize * id.y + _FftSize;

    
    float halfN = _FftSize / 2.0f;

    float n = id.x - _FftSize / 2.0f;
    float m = id.y - _FftSize / 2.0f;

    float2 K = float2(n, m) * 2.0f * PI / _LengthScale;
    float kLen = length(K);

    float2 gauss1 = BoxMullerTransform( JenkenHash(seed), JenkenHash(seed * seed));
    float2 gauss2 = BoxMullerTransform( JenkenHash(seed * seed * 0.25), JenkenHash(seed * seed * 2));

    float w_0 = 2.0f * PI / 200.0f;
    float dispersion = floor(sqrt(9.8f * length(K)) / w_0) * w_0 * _FrameTime;

    float2 h0 = SamplePhillipsSpec(K, float2(gauss1.x, gauss2.y));
    float2 h0conj = SamplePhillipsSpec(-K, float2(gauss1.y, gauss2.x));
    
    float2 htilde = ComplexMult(h0, EulerFormula(dispersion)) + ComplexMult(h0conj, EulerFormula(-dispersion));

    float2 displacementX = ComplexMult(htilde, float2(0, -K.x / kLen));
    float2 displacementZ = ComplexMult(htilde, float2(0, -K.y / kLen));

    if (kLen < 0.00001f) {
        displacementX = 0;
        displacementZ = 0;
    }

    _ProgSpectrumTex[id.xy] = htilde;
    _DisplacementTex[id.xy] = float4(displacementX, displacementZ);

}

float4 ComputeTwiddleFactorAndInputIndices(uint2 id) {
    uint b = _FftSize >> (id.x + 1);
    float2 mult = 2 * PI * float2(0.0f, 1.0f) / _FftSize;
    uint i = (2 * b * (id.y / b) + id.y % b) % _FftSize;
    float2 twiddle = ComplexExp(-mult * ((id.y / b) * b));

    return float4(twiddle, i, i + b);
}



//https://github.com/gasgiant/Ocean-URP
void ButterflyValues(uint step, uint index, out uint2 indices, out float2 twiddle)
{
    const float twoPi = 6.28318530718;
    uint b = SIZE >> (step + 1);
    uint w = b * (index / b);
    uint i = (w + index) % SIZE;
    sincos(-twoPi / SIZE * w, twiddle.y, twiddle.x);
    if (_Inverse)
        twiddle.y = -twiddle.y;
    indices = uint2(i, i + b);
}


//https://www.keithlantz.net/2011/11/ocean-simulation-part-two-using-the-fast-fourier-transform/
[numthreads(8, 8, 1)]
void CS_DFT(uint3 id : SV_DISPATCHTHREADID) {
    float halfN = _FftSize / 2.0f;

    float2 x = id.xy - halfN;

    float2 h = 0.0f;

    for (int m = 0; m < _FftSize; ++m) {
        float kz = 2.0f * PI * (m - halfN) / _LengthScale;
        for (int n = 0; n < _FftSize; ++n) {
            float kx = 2.0f * PI * (n - halfN) / _LengthScale;
            float2 K = float2(kx, kz); // Position in spec
            float kMag = length(K);
            float kdotx = dot(K, x);

            float2 c = EulerFormula(kdotx);
            float2 htilde = ComplexMult(_ProgSpectrumTex[uint2(n, m)], c);
            if (kMag < 0.001f) htilde = 0.0f;
            h += htilde;
        }
    }

    _HeightTex[id.xy] = h.x;
}

[numthreads(SIZE, 1, 1)]
void CS_FFT(uint3 id : SV_DISPATCHTHREADID){
    uint threadindex = id.x;
    uint2 targetIndex = _Direction ? id.yx : id.xy;;

    float4 input = _FourierTarget[targetIndex];

    groupBuffer[0][threadindex] = input;
    GroupMemoryBarrierWithGroupSync();
    bool flag = false;

    [unroll]
    for (uint step = 0; step < LOG_SIZE; ++step) {
        uint2 inputsIndices;
        float2 twiddle;
        ButterflyValues(step, threadindex, inputsIndices, twiddle);

        float4 v = groupBuffer[flag][inputsIndices.y];
        groupBuffer[!flag][threadindex] = groupBuffer[flag][inputsIndices.x] + float4(ComplexMult(twiddle, v.xy), ComplexMult(twiddle, v.zw));

        flag = !flag;
        GroupMemoryBarrierWithGroupSync();
    }


    _FourierTarget[targetIndex] = groupBuffer[flag][threadindex];
}

SamplerState PointSampler;
[numthreads(8, 8, 1)]
void GenerateNormalMap(uint3 id : SV_DispatchThreadID) {


    int2 texel = id.xy;

    float centerHeight = _HeightTex.Load(texel).r;

    float leftHeight = _HeightTex.Load(texel - int2(1, 0)).r;
    float rightHeight = _HeightTex.Load(texel + int2(1, 0)).r;
    float nearHeight = _HeightTex.Load(texel - int2(0, 1)).r;
    float farHeight = _HeightTex.Load(texel + int2(0, 1)).r;

    float dx = rightHeight - leftHeight;
    float dz = farHeight - nearHeight;


    float3 normal = normalize(float3(dx, 1.0f, dz));

    _NormalTex[texel] = float4(normal, 1.0f);


}

float4 Permute(float4 data, float2 id) {
    return data * (1.0f - 2.0f * ((id.x + id.y) % 2));
}

[numthreads(8, 8, 1)]
void Assemble(uint3 id: SV_DISPATCHTHREADID) {
    float4 htildeDisplacement = Permute(_DisplacementTex[id.xy], id);

    float2 dxdz = htildeDisplacement.rg;
    float2 dydxz = htildeDisplacement.ba;



    float3 displacement = float3(-1 * dxdz.x, dydxz.x, -1 * dxdz.y);



    _HeightTex[id.xy] = float4(displacement, 0.0f);
}

